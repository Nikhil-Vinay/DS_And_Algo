We know that:
1. Linear serch in an array takes O(n) time.
2. Binary search takes O(logN) time but it needs the array sorted.
3. Advanced binary search or ternary search even takes logrithmic time and needs the array sorted.

To reduce the searching time complexity or make the searching more efficient, we need hashing mechanism to store
the array. We can achieve the searching in O(1) time complexity with high level efficient hashing function.

ex: unordered_map and unourdered_set are example of hash based storage in c++.

// Hash Function.

Hashing functions are based on mathematical functions. There are two kinds of math functions:

One to one function.
Many to one function.

1. Very simple hash function:
    int array[3] = { 10, 20, 50};

    We can have an array of 50 elements and can store the elements at corresponding indexes.
    10 at index 10.
    20 at index 20.
    50 at index 50.

    It implements one to one math function.
    For searching it will take O(1) time but it is very uneffcient in space. It is highly unacceptable.

2. Hash function by modulus.
   h(i) = arr[i] % N   // N is total number of elements in array, N > i >= 0.

   This takes care of space but increases the hash collision. Many elements can get same output from hash
   function because this hash function is not a strong hash function.

   This implements many to one math function. 
   We need to have a list for each indexe to handle the hash collision.

3. Linear Prob hashing.

   By this method we dont have list at each index to handle hash collision. If a collision happens for index i
   then we start searching the empty index from (i+1) to N and where ever we get the empty index we place our
   element.
 
   H'(i) = (h(i) + n) % N   , N > n >= 0

   For searching, if we dont see the numer at index generated by hash function then we start searching from next
   index till end and if we get any empty index and end of the hash array, we declare number is not found.

4. Quadratic Prob Hashing.

   It is based on linear probe hashing concept but we see clustering in linear hashing as contiuous elements are
   stored at adjacent places creates clusters and many contiguous places are empty.

   To reduce clustor by linear probing, here we start filling by squaring at index. 
   Example: if hash collision happens at index i then we start searching new index to fill up the element as..
   i^2, (i+1)^2...so on. We apply same for searching also.
   By this way, elements are equally distributed in the hash array. They dont cluster at contiguous places.

   This concept is used in load balancer for horozontal scaled servers as well.

   Consistent hashing is very good example for load balancer. Study seperately consistent hashing. 
